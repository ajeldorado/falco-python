# % Copyright 2018-2020, by the California Institute of Technology. ALL RIGHTS
# % RESERVED. United States Government Sponsorship acknowledged. Any
# % commercial use must be negotiated with the Office of Technology Transfer
# % at the California Institute of Technology.
# % -------------------------------------------------------------------------
# % Function to create a rotated elliptical aperture.
# %
# % This function is needed because PROPER can generate only unrotated
# % ellipses. The grayscale edges of the ellipse are generated by creating a
# % binary-valued, higher-resolution sub-array of each pixel along the edge 
# % of the ellipse.
# %
# %--Required Icp.ts in the structure "icp.ts"
# % icp.ts['Nbeam % max aperture radius in samples
# % icp.ts['Narray % Number of samples across in square output array
# % icp.ts['radiusX % x-radius of ellipse [pupil diameters]
# % icp.ts['radiusY % y-radius of ellipse [pupil diameters]
# % icp.ts['clockingDegrees % clocking of the pupil [degrees]
# %
# %--Optional Icp.ts
# % icp.ts['centering
# % icp.ts['xShear % x-shear of ellipse [pupil diameters]
# % icp.ts['yShear % y-shear of ellipse [pupil diameters]
# % icp.ts['magFac % magnification factor


def falco_gen_ellipse(icp.ts):
    
    #--Required Icp.ts
    Nbeam = icp.ts['Nbeam']  # max aperture radius in samples
    Narray = icp.ts['Narray'] # Number of samples across in square output array
    radiusX = icp.ts['radiusX'] # x-radius of ellipse [pupil diameters]
    radiusY = icp.ts['radiusY'] # y-radius of ellipse [pupil diameters]
    clockingRadians = cp.pi/180.*icp.ts['clockingDegrees']
    
    #--Optional icp.ts
    if not 'centering' in icp.ts.keys(): icp.ts['centering'] = 'pixel'
    if not 'xShear' in icp.ts.keys(): icp.ts['xShear'] = 0.
    if not 'yShear' in icp.ts.keys(): icp.ts['yShear'] = 0.
    if not 'magFac' in icp.ts.keys(): icp.ts['magFac'] = 1.
    centering = icp.ts['centering']
    xShear = icp.ts['xShear']
    yShear = icp.ts['yShear']
    magFac = icp.ts['magFac']
    
    if centering == 'pixel':
        x = cp.linspace(-Narray/2., Narray/2. - 1, Narray)/float(Nbeam)
    elif centering == 'interpixel':
        x = cp.linspace(-(Narray-1)/2., (Narray-1)/2., Narray)/float(Nbeam)
    
    y = x
    x = x - xShear
    y = y - yShear
    [X, Y] = cp.meshgrid(x,y)
    dx = x[1] - x[0]
    radius = 0.5

    RHO = 1/magFac*0.5*cp.sqrt(
        1/(radiusX)**2*(cp.cos(clockingRadians)*X + cp.sin(clockingRadians)*Y)**2
        + 1/(radiusY)**2*(cp.sin(clockingRadians)*X - cp.cos(clockingRadians)*Y)**2
        )

    halfWindowWidth = cp.max(cp.abs((RHO[1, 0]-RHO[0, 0], RHO[0, 1] - RHO[0, 0])))
    pupil = -1*cp.ones(RHO.shape)
    pupil[cp.abs(RHO) < radius - halfWindowWidth] = 1
    pupil[cp.abs(RHO) > radius + halfWindowWidth] = 0
    grayInds = cp.array(cp.nonzero(pupil==-1))
    # print('Number of grayscale points = %d' % grayInds.shape[1])

    upsampleFactor = 100
    dxUp = dx/float(upsampleFactor)
    xUp = cp.linspace(-(upsampleFactor-1)/2., (upsampleFactor-1)/2., upsampleFactor)*dxUp
    [Xup, Yup] = cp.meshgrid(xUp, xUp)

    subpixel = cp.zeros((upsampleFactor,upsampleFactor))

    for iInterior in range(grayInds.shape[1]):

        subpixel = 0*subpixel

        xCenter = X[grayInds[0, iInterior], grayInds[1, iInterior]]
        yCenter = Y[grayInds[0, iInterior], grayInds[1, iInterior]]
        RHOup = 0.5*cp.sqrt(
        1/(radiusX)**2*(cp.cos(clockingRadians)*(Xup+xCenter) + cp.sin(clockingRadians)*(Yup+yCenter))**2
        + 1/(radiusY)**2*(cp.sin(clockingRadians)*(Xup+xCenter) - cp.cos(clockingRadians)*(Yup+yCenter))**2 
        )

        subpixel[RHOup <= radius] = 1
        pixelValue = cp.sum(subpixel)/float(upsampleFactor**2)
        pupil[grayInds[0, iInterior], grayInds[1, iInterior]] = pixelValue

    #plt.figure(2); plt.imshow(pupil); plt.colorbar(); plt.pause(0.1)

    return pupil